import{c as b}from"./config-BJNG_Aa3.js";const P={GONE:["A requested file or directory could not be found at the time the operation was processed.","NotFoundError"]};function v(r){return r instanceof Uint8Array}function E(r){return encodeURIComponent(r).replace(/[!'()*]/g,e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`)}const{WritableStream:S,TransformStream:y,DOMException:M,Blob:m}=b,{GONE:T}=P,C=/constructor/i.test(Function.prototype.toString.call(HTMLElement));class q{name;kind="file";writable=!0;constructor(e="unknown"){this.name=e}async getFile(){throw new M(...T)}async isSameEntry(e){return this===e}async remove(e){}async createWritable(e={}){const t=await navigator.serviceWorker?.getRegistration(),n=document.createElement("a"),a=new y,u=a.writable;if(n.download=this.name,C||!t){let o=[];a.readable.pipeTo(new WritableStream({write(s){o.push(new m([s]))},close(){const s=new m(o,{type:"application/octet-stream; charset=utf-8"});o=[],n.href=URL.createObjectURL(s),n.click(),window.setTimeout(()=>URL.revokeObjectURL(n.href),1e4)}})).catch(()=>{})}else{const{writable:o,readablePort:s}=new A(S),i=E(this.name),_={"content-disposition":"attachment; filename*=UTF-8''"+i,"content-type":"application/octet-stream; charset=utf-8",...e.size!==void 0?{"content-length":String(e.size)}:{}},f=window.setTimeout(()=>t.active?.postMessage(0),1e4);a.readable.pipeThrough(new y({async transform(l,d){if(v(l)){d.enqueue(l);return}const p=new Response(l).body;if(!p)return;const w=p.getReader(),h=async()=>{const{done:g,value:R}=await w.read();if(!g)return d.enqueue(R),h()};await h()}})).pipeTo(o).finally(()=>{clearTimeout(f)}),t.active?.postMessage({url:t.scope+i,headers:_,readablePort:s},[s]);const c=document.createElement("iframe");c.hidden=!0,c.src=t.scope+i,document.body.appendChild(c)}return u.getWriter()}}const O=0,U=0,L=1,W=1,j=2;class k{_port;_controller;_readyPromise;_readyResolve;_readyReject;_readyPending=!1;constructor(e){this._port=e,this._port.onmessage=t=>this._onMessage(t.data),this._resetReady()}start(e){return this._controller=e,this._readyPromise}write(e){const t={type:O,chunk:e};return this._port.postMessage(t,[e.buffer]),this._resetReady(),this._readyPromise}close(){const e={type:j};this._port.postMessage(e),this._port.close()}abort(e){const t={type:W,reason:e};this._port.postMessage(t),this._port.close()}_onMessage(e){e.type===U&&this._resolveReady(),e.type===L&&this._onError(e.reason)}_onError(e){this._controller.error(e),this._rejectReady(e),this._port.close()}_resetReady(){this._readyPromise=new Promise((e,t)=>{this._readyResolve=e,this._readyReject=t}),this._readyPending=!0}_resolveReady(){this._readyResolve(),this._readyPending=!1}_rejectReady(e){this._readyPending||this._resetReady(),this._readyPromise.catch(()=>{}),this._readyReject(e),this._readyPending=!1}}class A{readablePort;writable;constructor(e){const t=new MessageChannel;this.readablePort=t.port1,this.writable=new e(new k(t.port2))}}export{q as FileHandle};
